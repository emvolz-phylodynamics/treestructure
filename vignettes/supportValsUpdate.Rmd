---
title: "Node support values and update of treestructure object with new sequences"
author: "Vinicius Franceschi and Fabricia F Nascimento"
date: "`r Sys.Date()`"
output: 
  bookdown::html_vignette2:
  #rmarkdown::html_vignette
  #bookdown::pdf_book:
    toc: TRUE
pkgdown:
  as_is: true
fontsize: 12pt
vignette: >
  %\VignetteIndexEntry{Node support values and update of treestructure object with new sequences}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 11
)
```

# Introduction

In this tutorial, we will consider node support values (e.g. bootstrap and posterior probability) on 
cluster designations and update previous `treestructure` object with new sequences.

This tutorial uses the public data available for Ebola [here](https://github.com/ebov/space-time) to demonstrate the use of node support values to 
avoid designating population structure in badly supported clades. 

We will use a [time-scaled phylogenetic tree](https://github.com/ebov/space-time/blob/master/Data/Makona_1610_cds_ig.GLM.MCC.tree) estimated with [BEAST](https://beast.community).


Before we load this time-scaled tree, we will load the R packages we will use 
in this tutorial.


```{r message=FALSE}
library(stringr)
library(treeio)
library(treestructure)
```


Let's load this time-scaled tree with posterior probability support values:
```{r}
mltr2_outl_rm <- readRDS( system.file('mltr2_outl_rm_sc2_feb2020.rds', 
                                      package='treestructure') )

ggtree::ggtree(mltr2_outl_rm)
```

And here you can load the timetree:
```{r}
timetr2_phylo <- readRDS( system.file('timetr2_phylo_sc2_feb2020.rds', 
                                      package='treestructure') )

ggtree::ggtree(timetr2_phylo)
```


## Assign clusters without using node support

Firstly, we will assign clusters without using bootstrap support:
```{r eval=FALSE}
trestruct_res_nobt <- trestruct(timetr2_phylo, 
                                minCladeSize = 30, 
                                nodeSupportValues = FALSE, 
                                level = 0.01)
```

Because `treestructure` will take several minutes to run, we can load the results:

```{r}
trestruct_res_nobt <- readRDS( system.file('trestruct_res_nobt.rds',
                                           package='treestructure') )

plot(trestruct_res_nobt, use_ggtree = T) + ggtree::geom_tippoint()
```

The `treestructure` analyses resulted in 13 clusters.


## Assign clusters using bootstrap support

Let's add the support values to a vector that we will pass to `trestruct`:

```{r}
timetr2_boot <- as.integer(mltr2_outl_rm$node.label)

#note that IQ-TREE does not give a node support for the "root" of the tree,
#You, as a user with knowledge of your data, will decide if this should be 
#a high or low support value.
timetr2_boot[is.na(timetr2_boot)] <- 95

#show the first 6 node support values.
print(head(timetr2_boot))
```


Finally, we designate clusters that have at least 80% bootstrap support. This
is achieved by setting to 80 the parameter _nodeSupportThreshold_ in the **trestruct**
function.

```{r eval=FALSE}
trestruct_res <- trestruct(timetr2_phylo, 
                           minCladeSize = 30, 
                           nodeSupportValues = timetr2_boot, 
                           nodeSupportThreshold = 80, 
                           level = 0.01)
```

Because it will take a minute to run `treestructure`, we can load the result instead.

```{r}
trestruct_res <- readRDS( system.file('trestruct_res.rds',
                                      package='treestructure') )

plot(trestruct_res, use_ggtree = T) + ggtree::geom_tippoint()
```


Now we have only 4 well-supported clusters with differences in coalescent patterns.
Note that this might change if you use a higher or lower value for the
*nodeSupportThreshold* in the **trestruct** function.


## Update a previous treestrucuture object with new sequences 

To update the previous `treestructure` object with new sequences, we extracted 
SARS-CoV-2 sequences up to 15 March 2020 (n > 6,712 sequences). We then estimated 
a new ML tree including all those sequences as before.

Note that this new tree must be rooted, but does not need to be time-scaled or 
binary.

```{r}
#Note that this tree has more sequences than the previous tree used in this
#tutorial.
mltr_addtips <- readRDS( system.file('mltr_addtips_mar2020.rds', 
                                     package='treestructure') )
ggtree::ggtree(mltr_addtips)
```

And without the need to re-estimate a timetree or re-run `trestruct` from scratch, 
we are now able to add the new sequences to the existing `treestructure` object:

```{r}
trestruct_add_tips <- addtips(trst = trestruct_res, tre = mltr_addtips)
plot(trestruct_add_tips, use_ggtree = T) + ggtree::geom_tippoint()
```


If you would like to compare the sequence names that comprise each cluster in
each tree, you can do:

```{r}

#compare sequences in cluster 1 from trestruct_res object and the 
#trestruct_add_tips object

tree1_cluster1 <- trestruct_res$clusterSets$`1`
tree2_cluster1 <- trestruct_add_tips$clusterSets$`1`

length(tree1_cluster1)
length(tree2_cluster1)

```

Note that the length of tree1_cluster1 and tree2_cluster1 is different.
That is because we _added_ tips from the ML tree, _mltr_addtips_, to the 
`treestructure` object, _trestruct_res_.

You can also see that all elements in tree1_cluster1 is contained in tree2_cluster1

```{r}

sum(tree1_cluster1 %in% tree2_cluster1)

```
